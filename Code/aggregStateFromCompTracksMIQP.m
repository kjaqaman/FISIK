function [compTracksOut] = aggregStateFromCompTracksMIQP(compTracks,intensityInfo,numFramesInt)
%AGGREGSTATEFROMCOMPTRACKSMIQP recovers particle oligomeric states from compound tracks by solving a mixed-integer quadratic programming problem (MIQP)
%
%SYNOPSIS compTracksOut = aggregStateFromCompTracksMIQP(compTracks,intensityInfo,numFramesInt)
%
%INPUT  compTracks   : Compound tracks, in the format of tracksFinal as
%                      output by receptorAggregationSimpleOptimized (it is
%                      a field of the structure receptorInfoLabeled).
%       intensityInfo: Row vector with unit intensity mean and standard
%                      deviation (e.g. the intensity of a single
%                      fluorophore labeling a single receptor).
%       numFramesInt : Number of frames for intensity calculation per track
%                      segment.
%                      Optional. Default: All frames of each segment.
%
%OUTPUT compTracks   : -Structure with the 2 fields: "defaultFormatTracks" and
%                       "alternativeFormatTracks".
%                      -Both contain the fields "tracksFeatIndxCG",
%                       "tracksCoordAmpCG", "seqOfEvents" and "aggregState".
%                      -"alternativeFormatTracks" also contains the field
%                       "alt2defSegmentCorrespond".
%                      -"defaultFormatTracks" is the format of the output of
%                       "trackCloseGapsKalmanSparse" (or u-track for the GUI version).
%                      -"alternativeFormatTracks" is the format generated by
%                       the function "convFormatDefault2Alt", where tracks
%                       do not continue through merges and splits, but a
%                       merge consists of 2 track segments merging to form a
%                       3rd segment, and a split consists of 1 track segment
%                       splitting into 2 different segments.
%                      -The field "aggregState" has the same dimensions as
%                       "tracksFeatIndxCG", and indicates the estimated
%                       number of units (e.g. receptors) within each
%                       detected particle/feature.
%
%
%Khuloud Jaqaman, February 2009
%       Modified, January 2013, Robel Yirdaw
%       Modified, 2014/12/12, Robel Yirdaw
%       Modified 2018/10/30, Luciana de Oliveira
%       Modified 2019/04/17, Khuloud Jaqaman
%       Modified 2019/04/24, Luciana de Oliveira
%
% Copyright (C) 2019, Jaqaman Lab - UTSouthwestern
%
% This file is part of FISIK.
%
% FISIK is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% FISIK is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with FISIK.  If not, see <http://www.gnu.org/licenses/>.
%
%

%% Input

if nargin < 2 || isempty(intensityInfo)
    error('aggregStateFromCompTracksMIQP: Missing input arguments')
end

if nargin < 3 || isempty(numFramesInt)
    numFramesInt = [];
end

%construct vector of integer multiples of mean unit intensity
intMean=intensityInfo(1);
multUnitAmp = intMean*(1:100)';

%get number of compound tracks
numTracks = length(compTracks);

%convert tracks from default format (output of trackCloseGapsKalman) to
%alternative format where there is no track continuation through a merge or
%a split
compTracksDef = compTracks;
% fprintf('\nIn aggregState...entering convTrackFormatDefault2Alt...');
% convDef2AltTic = tic;
compTracks = convTrackFormatDefault2Alt(compTracksDef);
% convDef2AltTime = toc(convDef2AltTic);
% fprintf('\nDone with convTrackFormatDefault2Alt. Elapsed time is %g seconds.\n',convDef2AltTime);


%% Calculation

%go over all compound tracks
for iTrack = 1 : numTracks
    
    %     fprintf('\nIn aggregState...at iTrack %d',iTrack);
    
    %get this compound track's information
    seqOfEvents = compTracks(iTrack).seqOfEvents;
    tracksFeatIndx = compTracks(iTrack).tracksFeatIndxCG;
    tracksAmp = compTracks(iTrack).tracksCoordAmpCG(:,4:8:end);
    
    %KJ 190417: We no longer use double frequencies, so I am commenting out
    %this line and forcing flag to 0.
    %New changes in code assume double frequency flag is always 0 and do
    %not use it.
    
    %     %determine whether track is sampled regularly or with doubled frequency
    %     doubleFreq = mod(seqOfEvents(1,1)*2,2)==1;
    doubleFreq = 0;
    
    %shift time in seqOfEvents to make the track start at frame 1 or 0.5
    %if sampling frequency is doubled
    seqOfEvents(:,1) = seqOfEvents(:,1) - seqOfEvents(1,1) + 1/(1+doubleFreq);
    
    % transform intensity from sparse to full form, replace zeros with NaNs
    tracksAmp = full(tracksAmp);
    tracksAmp(tracksAmp==0)=NaN;
    
    %get the start frame, end frame, and number of frames of each track segment
    numSeg = size(tracksAmp,1);
    segmentSEL = NaN(numSeg,2);
    for iSeg = 1 : numSeg
        segmentSEL(iSeg,1:2) = [find(~isnan(tracksAmp(iSeg,:)),1,'first') find(~isnan(tracksAmp(iSeg,:)),1,'last')];
    end
    
    %initialize matrix storing aggregation state with ones
    aggregStateMat = full(tracksFeatIndx);
    aggregStateMat = double((aggregStateMat ~= 0));
    aggregStateMat(aggregStateMat==0) = NaN;
    
    if numSeg == 1 %If no merges or splits ...
        
        %get this track's average intensity
        %handle sparse (0) and non-sparse (NaN) data
        %cut to number of frames of interest if input
        if numFramesInt < segmentSEL(2)
            tracksAmp = tracksAmp(1:numFramesInt);
        end
        meanAmp = nanmean(tracksAmp); % tracksAmp(:,(~isnan(tracksAmp) & (tracksAmp ~= 0))) );
        
        %subtract the integer multiples of the unit intensity from the
        %track's mean intensity
        meanAmpMinusMultUnitAmp = abs(meanAmp - multUnitAmp);
        
        %determine integer multiple yielding smallest difference
        intMult = find(meanAmpMinusMultUnitAmp==min(meanAmpMinusMultUnitAmp));
        
        %assign this value to the aggregation state of this track
        aggregStateMat = aggregStateMat * intMult;
        
    else %If there are merge and/or split events ...
        
        %find all merging and splitting events
        msEvents = find(~isnan(seqOfEvents(:,4)));
        
        %determine the segments that are interacting
        segmentsInteracting=unique(seqOfEvents(msEvents,3:4));
        
        % define x:
        x = sdpvar(length(segmentsInteracting),1);
        
        % initiate Constraints
        Constraints = integer(x);
        
        %%%%%% Modification LRO 2019/04/24
        %%%%with the subsampling of the simulations can have situations where multiple segments merge/split in the same time
        % add condition to deal with it
        
        %check if there are multiple events in the same frame
        
        % identify the frames where the events are happening
        timeEvents=seqOfEvents( msEvents,1);
        
        %identify the unique times
        uniqueTimeEvents=unique(timeEvents);
        
        % go over every time
        for indexTime=1:length(uniqueTimeEvents)
            
            % identify where the events with this time are happening,
            % only for merges and splits
            iEventMS= find(seqOfEvents(:,1)==uniqueTimeEvents(indexTime)&~isnan(seqOfEvents(:,4)));
            
            % check number of events in this particular time and if
            % there are multiple events in the same time
            numberEvents=length(iEventMS);
            
            if numberEvents>2
                %Check if the events are happening with the same
                %segment multiple times
                segmentInteraction=seqOfEvents( iEventMS,4);
                %count how many times each segment appears
                %determine which ones are the same and how much times it appears
                uniqueSegment=unique(segmentInteraction);
                %count the repetitions
                segmentRepetition=histc(segmentInteraction,uniqueSegment);
            else
                segmentRepetition=2;
            end
            
            %%%%% LRO, add constrains for multiple segments interacting.
            for indxEvent=1:length(segmentRepetition)
                %identify which are the rows where this specific event
                %is happening
                rowEvent=iEventMS(1);
                %remove these events from the list of events
                iEventMS(1:segmentRepetition(indxEvent))=[];
                
                if seqOfEvents( rowEvent,2)==2 % if the event is a merge
                    
                    switch segmentRepetition(indxEvent)
                        case 2
                            Constraints=[Constraints, x(seqOfEvents( rowEvent,3))+x(seqOfEvents( rowEvent+1,3))-x(seqOfEvents( rowEvent,4))==0];
                        case 3
                            Constraints=[Constraints, x(seqOfEvents( rowEvent,3))+x(seqOfEvents( rowEvent+1,3))+x(seqOfEvents( rowEvent+2,3))-x(seqOfEvents( rowEvent,4))==0];
                        case 4
                            Constraints=[Constraints, x(seqOfEvents( rowEvent,3))+x(seqOfEvents( rowEvent+1,3))+x(seqOfEvents( rowEvent+2,3))+x(seqOfEvents( rowEvent+3,3))-x(seqOfEvents( rowEvent,4))==0];
                        otherwise
                            error('more than 4 segments interacting at the same time')
                            
                    end
                    
                elseif seqOfEvents( rowEvent,2)==1 % if it is a split
                    
                    switch segmentRepetition(indxEvent)
                        case 2
                            Constraints=[Constraints, -x(seqOfEvents( rowEvent,3))-x(seqOfEvents( rowEvent+1,3))+x(seqOfEvents( rowEvent,4))==0];
                        case 3
                            Constraints=[Constraints, -x(seqOfEvents( rowEvent,3))-x(seqOfEvents( rowEvent+1,3))-x(seqOfEvents( rowEvent+2,3))+x(seqOfEvents( rowEvent,4))==0];
                        case 4
                            Constraints=[Constraints, -x(seqOfEvents( rowEvent,3))-x(seqOfEvents( rowEvent+1,3))-x(seqOfEvents( rowEvent+2,3))-x(seqOfEvents( rowEvent+3,3))+x(seqOfEvents( rowEvent,4))==0];
                        otherwise
                            error('more than 4 segments interacting at the same time')
                    end
                    
                end
                
            end %(for indxEvent=1:length(segmentRepetition))
            
        end %(for indexTime=1:length(uniqueTimeEvents))
        
        % add lower boundary condition
        for i=1:length(segmentsInteracting)
            Constraints = [Constraints, x(i)>=1];
        end
        
        % calculate the mean intensity for each segment
        if isempty(numFramesInt)
            
            IntensityVector=nanmean(tracksAmp,2);
            
        else %cut to number of frames of interest if input
            
            lastFrame2Take = min([segmentSEL(:,2) segmentSEL(:,1)+numFramesInt-1],[],2);
            IntensityVector = NaN(numSeg,1);
            for iSeg = 1 : numSeg
                IntensityVector(iSeg) = nanmean(tracksAmp(iSeg,segmentSEL(iSeg,1):lastFrame2Take(iSeg)));
            end
            
        end
        
        % define the objective function
        Objective = 0.5*intMean*(x'*x) - IntensityVector'*x;
        
        % define the options for the calculations
        options = sdpsettings('verbose',0,'solver','BNB','BNB.maxiter',5000); %% LRO Modified the solver
        
        % calculate the solution
        sol = optimize(Constraints,Objective,options);
        
        % output the aggreg state
        aggregSizes = value(x);
        
        % check if the aggregState was calculated correctly
        if any(aggregSizes==0)
            error('null aggreg state, check number of iterations in options')
        end
        
        % replace values of aggregSize in the  aggregStateMat
        aggregStateMat=aggregSizes.*aggregStateMat;
        
    end %(if numSeg == 1 ... else ...)
    
    %% store aggregation state matrix in compound tracks structure with default format
    
    %get number of segments in default format
    numSegmentsDef = size(compTracksDef(iTrack).tracksFeatIndxCG,1);
    
    %copy aggregation state matrix
    aggregStateDef = aggregStateMat(1:numSegmentsDef,:);
    
    %copy out segment correspondence array
    segmentCorrespond = compTracks(iTrack).alt2defSegmentCorrespond;
    
    %go over additional segments in alternative format and store their
    %aggregation state in the original segment location
    for iSegment = 1 : size(segmentCorrespond,1)
        segmentNew = segmentCorrespond(iSegment,1);
        segmentOld = segmentCorrespond(iSegment,2);
        aggregStateDef(segmentOld,:) = max([aggregStateDef(segmentOld,:);...
            aggregStateMat(segmentNew,:)]);
    end
    
    %Moved from above with conversion to sparse added
    if (issparse(compTracks(iTrack).tracksCoordAmpCG))
        aggregStateMat(isnan(aggregStateMat)) = 0;
        compTracks(iTrack).aggregState = sparse(aggregStateMat);
        %Also converting to sparse the original line below
        aggregState = aggregStateDef(:,1+doubleFreq:(1+doubleFreq):end);
        aggregState(isnan(aggregState)) = 0;
        compTracksDef(iTrack).aggregState = sparse(aggregState);
    else
        compTracks(iTrack).aggregState = aggregStateMat;
        compTracksDef(iTrack).aggregState = aggregStateDef(:,1+doubleFreq:(1+doubleFreq):end);
    end
    
end %(for iTrack = 1 : numTracks)

%store results in output structure
compTracksOut = struct('defaultFormatTracks',compTracksDef,'alternativeFormatTracks',...
    compTracks);

%% ~~~ the end ~~~

end



